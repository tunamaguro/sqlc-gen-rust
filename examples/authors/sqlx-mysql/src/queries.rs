//! Code generated by sqlc-gen-rust. SHOULD NOT EDIT.
//! sqlc version: v1.30.0
//! sqlc-gen-rust version: v0.1.11

#[derive(sqlx::FromRow)]
pub struct GetAuthorRow {
    #[sqlx(rename = "id")]
    pub id: i64,
    #[sqlx(rename = "name")]
    pub name: String,
    #[sqlx(rename = "bio")]
    pub bio: Option<String>,
}
pub struct GetAuthor {
    id: i64,
}
impl GetAuthor {
    pub const QUERY: &'static str = r"SELECT id, name, bio FROM authors
WHERE id = ? LIMIT 1";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::MySql,
        GetAuthorRow,
        <sqlx::MySql as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, GetAuthorRow>(Self::QUERY).bind(self.id)
    }
    pub fn query_one<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<GetAuthorRow, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::MySql> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let val = self.query_as().fetch_one(&mut *conn).await?;
            Ok(val)
        }
    }
    pub fn query_opt<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Option<GetAuthorRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::MySql> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let val = self.query_as().fetch_optional(&mut *conn).await?;
            Ok(val)
        }
    }
}
impl GetAuthor {
    pub const fn builder() -> GetAuthorBuilder<'static, ((),)> {
        GetAuthorBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct GetAuthorBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> GetAuthorBuilder<'a, ((),)> {
    pub fn id(self, id: i64) -> GetAuthorBuilder<'a, (i64,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        GetAuthorBuilder {
            fields: (id,),
            _phantom,
        }
    }
}
impl<'a> GetAuthorBuilder<'a, (i64,)> {
    pub const fn build(self) -> GetAuthor {
        let (id,) = self.fields;
        GetAuthor { id }
    }
}
#[derive(sqlx::FromRow)]
pub struct ListAuthorsRow {
    #[sqlx(rename = "id")]
    pub id: i64,
    #[sqlx(rename = "name")]
    pub name: String,
    #[sqlx(rename = "bio")]
    pub bio: Option<String>,
}
pub struct ListAuthors;
impl ListAuthors {
    pub const QUERY: &'static str = r"SELECT id, name, bio FROM authors
ORDER BY name";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::MySql,
        ListAuthorsRow,
        <sqlx::MySql as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, ListAuthorsRow>(Self::QUERY)
    }
    pub fn query_many<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Vec<ListAuthorsRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::MySql> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let vals = self.query_as().fetch_all(&mut *conn).await?;
            Ok(vals)
        }
    }
}
impl ListAuthors {
    pub const fn builder() -> ListAuthorsBuilder<'static, ()> {
        ListAuthorsBuilder {
            fields: (),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct ListAuthorsBuilder<'a, Fields = ()> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> ListAuthorsBuilder<'a, ()> {
    pub const fn build(self) -> ListAuthors {
        let () = self.fields;
        ListAuthors {}
    }
}
#[derive(sqlx::FromRow)]
pub struct CreateAuthorRow {}
pub struct CreateAuthor<'a> {
    name: &'a str,
    bio: Option<&'a str>,
}
impl<'a> CreateAuthor<'a> {
    pub const QUERY: &'static str = r"INSERT INTO authors (
  name, bio
) VALUES (
  ?, ? 
)";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::MySql,
        CreateAuthorRow,
        <sqlx::MySql as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, CreateAuthorRow>(Self::QUERY).bind(self.name).bind(self.bio)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<
        Output = Result<<sqlx::MySql as sqlx::Database>::QueryResult, sqlx::Error>,
    > + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::MySql> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.name)
                .bind(self.bio)
                .execute(&mut *conn)
                .await
        }
    }
}
impl<'a> CreateAuthor<'a> {
    pub const fn builder() -> CreateAuthorBuilder<'a, ((), ())> {
        CreateAuthorBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CreateAuthorBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Bio> CreateAuthorBuilder<'a, ((), Bio)> {
    pub fn name(self, name: &'a str) -> CreateAuthorBuilder<'a, (&'a str, Bio)> {
        let ((), bio) = self.fields;
        let _phantom = self._phantom;
        CreateAuthorBuilder {
            fields: (name, bio),
            _phantom,
        }
    }
}
impl<'a, Name> CreateAuthorBuilder<'a, (Name, ())> {
    pub fn bio(
        self,
        bio: Option<&'a str>,
    ) -> CreateAuthorBuilder<'a, (Name, Option<&'a str>)> {
        let (name, ()) = self.fields;
        let _phantom = self._phantom;
        CreateAuthorBuilder {
            fields: (name, bio),
            _phantom,
        }
    }
}
impl<'a> CreateAuthorBuilder<'a, (&'a str, Option<&'a str>)> {
    pub const fn build(self) -> CreateAuthor<'a> {
        let (name, bio) = self.fields;
        CreateAuthor { name, bio }
    }
}
#[derive(sqlx::FromRow)]
pub struct DeleteAuthorRow {}
pub struct DeleteAuthor {
    id: i64,
}
impl DeleteAuthor {
    pub const QUERY: &'static str = r"DELETE FROM authors
WHERE id = ?";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::MySql,
        DeleteAuthorRow,
        <sqlx::MySql as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, DeleteAuthorRow>(Self::QUERY).bind(self.id)
    }
    pub fn execute<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<
        Output = Result<<sqlx::MySql as sqlx::Database>::QueryResult, sqlx::Error>,
    > + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::MySql> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY).bind(self.id).execute(&mut *conn).await
        }
    }
}
impl DeleteAuthor {
    pub const fn builder() -> DeleteAuthorBuilder<'static, ((),)> {
        DeleteAuthorBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct DeleteAuthorBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> DeleteAuthorBuilder<'a, ((),)> {
    pub fn id(self, id: i64) -> DeleteAuthorBuilder<'a, (i64,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        DeleteAuthorBuilder {
            fields: (id,),
            _phantom,
        }
    }
}
impl<'a> DeleteAuthorBuilder<'a, (i64,)> {
    pub const fn build(self) -> DeleteAuthor {
        let (id,) = self.fields;
        DeleteAuthor { id }
    }
}
#[derive(sqlx::FromRow)]
pub struct GetAuthorsByIdsRow {
    #[sqlx(rename = "id")]
    pub id: i64,
    #[sqlx(rename = "name")]
    pub name: String,
    #[sqlx(rename = "bio")]
    pub bio: Option<String>,
}
pub struct GetAuthorsByIds<'a> {
    ids: &'a [i64],
}
impl<'a> GetAuthorsByIds<'a> {
    pub const QUERY: &'static str = r"SELECT id, name, bio FROM authors
WHERE id IN (/*SLICE:ids*/?)";
    fn expand_query(&self) -> String {
        let mut query = Self::QUERY.to_string();
        if self.ids.is_empty() {
            query = query.replacen("/*SLICE:ids*/?", "NULL", 1);
        } else {
            query = query
                .replacen("/*SLICE:ids*/?", &",?".repeat(self.ids.len())[1..], 1);
        }
        query
    }
    pub fn query_many<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Vec<GetAuthorsByIdsRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::MySql> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let query_str = self.expand_query();
            let mut q = sqlx::query_as::<_, GetAuthorsByIdsRow>(&query_str);
            for v in self.ids {
                q = q.bind(v);
            }
            let vals = q.fetch_all(&mut *conn).await?;
            Ok(vals)
        }
    }
}
impl<'a> GetAuthorsByIds<'a> {
    pub const fn builder() -> GetAuthorsByIdsBuilder<'a, ((),)> {
        GetAuthorsByIdsBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct GetAuthorsByIdsBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> GetAuthorsByIdsBuilder<'a, ((),)> {
    pub fn ids(self, ids: &'a [i64]) -> GetAuthorsByIdsBuilder<'a, (&'a [i64],)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        GetAuthorsByIdsBuilder {
            fields: (ids,),
            _phantom,
        }
    }
}
impl<'a> GetAuthorsByIdsBuilder<'a, (&'a [i64],)> {
    pub const fn build(self) -> GetAuthorsByIds<'a> {
        let (ids,) = self.fields;
        GetAuthorsByIds { ids }
    }
}
#[derive(sqlx::FromRow)]
pub struct GetAuthorsByIdsAndNameRow {
    #[sqlx(rename = "id")]
    pub id: i64,
    #[sqlx(rename = "name")]
    pub name: String,
    #[sqlx(rename = "bio")]
    pub bio: Option<String>,
}
pub struct GetAuthorsByIdsAndName<'a> {
    name: &'a str,
    ids: &'a [i64],
}
impl<'a> GetAuthorsByIdsAndName<'a> {
    pub const QUERY: &'static str = r"SELECT id, name, bio FROM authors
WHERE name = ? AND id IN (/*SLICE:ids*/?)";
    fn expand_query(&self) -> String {
        let mut query = Self::QUERY.to_string();
        if self.ids.is_empty() {
            query = query.replacen("/*SLICE:ids*/?", "NULL", 1);
        } else {
            query = query
                .replacen("/*SLICE:ids*/?", &",?".repeat(self.ids.len())[1..], 1);
        }
        query
    }
    pub fn query_many<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<
        Output = Result<Vec<GetAuthorsByIdsAndNameRow>, sqlx::Error>,
    > + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::MySql> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let query_str = self.expand_query();
            let mut q = sqlx::query_as::<_, GetAuthorsByIdsAndNameRow>(&query_str);
            q = q.bind(self.name);
            for v in self.ids {
                q = q.bind(v);
            }
            let vals = q.fetch_all(&mut *conn).await?;
            Ok(vals)
        }
    }
}
impl<'a> GetAuthorsByIdsAndName<'a> {
    pub const fn builder() -> GetAuthorsByIdsAndNameBuilder<'a, ((), ())> {
        GetAuthorsByIdsAndNameBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct GetAuthorsByIdsAndNameBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Ids> GetAuthorsByIdsAndNameBuilder<'a, ((), Ids)> {
    pub fn name(
        self,
        name: &'a str,
    ) -> GetAuthorsByIdsAndNameBuilder<'a, (&'a str, Ids)> {
        let ((), ids) = self.fields;
        let _phantom = self._phantom;
        GetAuthorsByIdsAndNameBuilder {
            fields: (name, ids),
            _phantom,
        }
    }
}
impl<'a, Name> GetAuthorsByIdsAndNameBuilder<'a, (Name, ())> {
    pub fn ids(
        self,
        ids: &'a [i64],
    ) -> GetAuthorsByIdsAndNameBuilder<'a, (Name, &'a [i64])> {
        let (name, ()) = self.fields;
        let _phantom = self._phantom;
        GetAuthorsByIdsAndNameBuilder {
            fields: (name, ids),
            _phantom,
        }
    }
}
impl<'a> GetAuthorsByIdsAndNameBuilder<'a, (&'a str, &'a [i64])> {
    pub const fn build(self) -> GetAuthorsByIdsAndName<'a> {
        let (name, ids) = self.fields;
        GetAuthorsByIdsAndName {
            name,
            ids,
        }
    }
}
