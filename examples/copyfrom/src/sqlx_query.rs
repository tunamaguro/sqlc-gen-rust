//! Code generated by sqlc-gen-rust. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-gen-rust version: v0.1.9

pub struct CopyDataSink<C: std::ops::DerefMut<Target = sqlx::PgConnection>> {
    encode_buf: sqlx::postgres::PgArgumentBuffer,
    data_buf: Vec<u8>,
    copy_in: sqlx::postgres::PgCopyIn<C>,
}
impl<C: std::ops::DerefMut<Target = sqlx::PgConnection>> CopyDataSink<C> {
    const BUFFER_SIZE: usize = 4096;
    fn new(copy_in: sqlx::postgres::PgCopyIn<C>) -> Self {
        let mut data_buf = Vec::with_capacity(Self::BUFFER_SIZE);
        const COPY_SIGNATURE: &[u8] = &[
            b'P', b'G', b'C', b'O', b'P', b'Y', b'\n', 0xFF, b'\r', b'\n', 0x00,
        ];
        assert_eq!(COPY_SIGNATURE.len(), 11);
        data_buf.extend_from_slice(COPY_SIGNATURE);
        data_buf.extend(0_i32.to_be_bytes());
        data_buf.extend(0_i32.to_be_bytes());
        CopyDataSink {
            encode_buf: Default::default(),
            data_buf,
            copy_in,
        }
    }
    async fn send(&mut self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let _copy_in = self.copy_in.send(self.data_buf.as_slice()).await?;
        self.data_buf.clear();
        Ok(())
    }
    /// Complete copy process and return number of rows affected.
    pub async fn finish(mut self) -> Result<u64, Box<dyn std::error::Error + Send + Sync>> {
        const COPY_TRAILER: &[u8] = &(-1_i16).to_be_bytes();
        self.data_buf.extend(COPY_TRAILER);
        self.send().await?;
        self.copy_in.finish().await.map_err(|e| e.into())
    }
    fn insert_row(&mut self) {
        let num_col = self.copy_in.num_columns() as i16;
        self.data_buf.extend(num_col.to_be_bytes());
    }
    async fn add<'q, T>(
        &mut self,
        value: &T,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
    where
        T: sqlx::Encode<'q, sqlx::Postgres> + sqlx::Type<sqlx::Postgres>,
    {
        let is_null = value.encode_by_ref(&mut self.encode_buf)?;
        match is_null {
            sqlx::encode::IsNull::Yes => {
                self.data_buf.extend((-1_i32).to_be_bytes());
            }
            sqlx::encode::IsNull::No => {
                self.data_buf
                    .extend((self.encode_buf.len() as i32).to_be_bytes());
                self.data_buf.extend_from_slice(self.encode_buf.as_slice());
            }
        }
        self.encode_buf.clear();
        if self.data_buf.len() > Self::BUFFER_SIZE {
            self.send().await?;
        }
        Ok(())
    }
}
#[derive(sqlx::FromRow)]
pub struct GetAuthorRow {
    #[sqlx(rename = "id")]
    pub id: i64,
    #[sqlx(rename = "name")]
    pub name: String,
    #[sqlx(rename = "bio")]
    pub bio: Option<String>,
}
pub struct GetAuthor {
    id: i64,
}
impl GetAuthor {
    pub const QUERY: &'static str = r"SELECT id, name, bio FROM authors
WHERE id = $1 LIMIT 1";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        GetAuthorRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, GetAuthorRow>(Self::QUERY).bind(self.id)
    }
    pub fn query_one<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<GetAuthorRow, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let val = self.query_as().fetch_one(&mut *conn).await?;
            Ok(val)
        }
    }
    pub fn query_opt<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Option<GetAuthorRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let val = self.query_as().fetch_optional(&mut *conn).await?;
            Ok(val)
        }
    }
}
impl GetAuthor {
    pub const fn builder() -> GetAuthorBuilder<'static, ((),)> {
        GetAuthorBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct GetAuthorBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> GetAuthorBuilder<'a, ((),)> {
    pub fn id(self, id: i64) -> GetAuthorBuilder<'a, (i64,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        GetAuthorBuilder {
            fields: (id,),
            _phantom,
        }
    }
}
impl<'a> GetAuthorBuilder<'a, (i64,)> {
    pub const fn build(self) -> GetAuthor {
        let (id,) = self.fields;
        GetAuthor { id }
    }
}
#[derive(sqlx::FromRow)]
pub struct CreateAuthorsRow {}
pub struct CreateAuthors<'a> {
    id: i64,
    name: &'a str,
    bio: Option<&'a str>,
}
impl<'a> CreateAuthors<'a> {
    pub const QUERY: &'static str = r"COPY authors (id,name,bio) FROM STDIN (FORMAT BINARY)";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        CreateAuthorsRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, CreateAuthorsRow>(Self::QUERY)
            .bind(self.id)
            .bind(self.name)
            .bind(self.bio)
    }
    pub async fn copy_in<PgCopy>(
        conn: &PgCopy,
    ) -> Result<CopyDataSink<sqlx::pool::PoolConnection<sqlx::Postgres>>, sqlx::Error>
    where
        PgCopy: sqlx::postgres::PgPoolCopyExt,
    {
        let copy_in = conn.copy_in_raw(Self::QUERY).await?;
        Ok(CopyDataSink::new(copy_in))
    }
    pub async fn copy_in_tx(
        conn: &mut sqlx::postgres::PgConnection,
    ) -> Result<CopyDataSink<&mut sqlx::postgres::PgConnection>, sqlx::Error> {
        let copy_in = conn.copy_in_raw(Self::QUERY).await?;
        Ok(CopyDataSink::new(copy_in))
    }
    pub async fn write<C: std::ops::DerefMut<Target = sqlx::PgConnection>>(
        &self,
        sink: &mut CopyDataSink<C>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        sink.insert_row();
        sink.add(&self.id).await?;
        sink.add(&self.name).await?;
        sink.add(&self.bio).await?;
        Ok(())
    }
}
impl<'a> CreateAuthors<'a> {
    pub const fn builder() -> CreateAuthorsBuilder<'a, ((), (), ())> {
        CreateAuthorsBuilder {
            fields: ((), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CreateAuthorsBuilder<'a, Fields = ((), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Name, Bio> CreateAuthorsBuilder<'a, ((), Name, Bio)> {
    pub fn id(self, id: i64) -> CreateAuthorsBuilder<'a, (i64, Name, Bio)> {
        let ((), name, bio) = self.fields;
        let _phantom = self._phantom;
        CreateAuthorsBuilder {
            fields: (id, name, bio),
            _phantom,
        }
    }
}
impl<'a, Id, Bio> CreateAuthorsBuilder<'a, (Id, (), Bio)> {
    pub fn name(self, name: &'a str) -> CreateAuthorsBuilder<'a, (Id, &'a str, Bio)> {
        let (id, (), bio) = self.fields;
        let _phantom = self._phantom;
        CreateAuthorsBuilder {
            fields: (id, name, bio),
            _phantom,
        }
    }
}
impl<'a, Id, Name> CreateAuthorsBuilder<'a, (Id, Name, ())> {
    pub fn bio(
        self,
        bio: Option<&'a str>,
    ) -> CreateAuthorsBuilder<'a, (Id, Name, Option<&'a str>)> {
        let (id, name, ()) = self.fields;
        let _phantom = self._phantom;
        CreateAuthorsBuilder {
            fields: (id, name, bio),
            _phantom,
        }
    }
}
impl<'a> CreateAuthorsBuilder<'a, (i64, &'a str, Option<&'a str>)> {
    pub const fn build(self) -> CreateAuthors<'a> {
        let (id, name, bio) = self.fields;
        CreateAuthors { id, name, bio }
    }
}
