//! Code generated by sqlc-gen-rust. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-gen-rust version: v0.1.4

use tokio_postgres::types::ToSql;
#[derive(Debug, Clone, Copy, postgres_types::ToSql, postgres_types::FromSql)]
#[postgres(name = "status")]
pub enum Status {
    #[postgres(name = "op!en")]
    Open,
    #[postgres(name = "clo@sed")]
    Closed,
}
pub struct ListCitiesRow {
    pub slug: String,
    pub name: String,
}
impl ListCitiesRow {
    pub fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(Self {
            slug: row.try_get(0)?,
            name: row.try_get(1)?,
        })
    }
}
pub struct ListCities;
impl ListCities {
    pub const QUERY: &'static str = r"SELECT slug, name
FROM city
ORDER BY name";
    pub async fn query_many(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Vec<ListCitiesRow>, tokio_postgres::Error> {
        let rows = client.query(Self::QUERY, &[]).await?;
        rows.into_iter()
            .map(|r| ListCitiesRow::from_row(&r))
            .collect()
    }
    pub async fn query_stream(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<tokio_postgres::RowStream, tokio_postgres::Error> {
        let st = client
            .query_raw(Self::QUERY, self.as_slice().into_iter())
            .await?;
        Ok(st)
    }
    pub fn as_slice(&self) -> [&(dyn ToSql + Sync); 0] {
        []
    }
}
impl ListCities {
    pub const fn builder() -> ListCitiesBuilder<'static, ()> {
        ListCitiesBuilder {
            fields: (),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct ListCitiesBuilder<'a, Fields = ()> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> ListCitiesBuilder<'a, ()> {
    pub const fn build(self) -> ListCities {
        let () = self.fields;
        ListCities {}
    }
}
pub struct GetCityRow {
    pub slug: String,
    pub name: String,
}
impl GetCityRow {
    pub fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(Self {
            slug: row.try_get(0)?,
            name: row.try_get(1)?,
        })
    }
}
pub struct GetCity<'a> {
    slug: &'a str,
}
impl<'a> GetCity<'a> {
    pub const QUERY: &'static str = r"SELECT slug, name
FROM city
WHERE slug = $1";
    pub async fn query_one(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<GetCityRow, tokio_postgres::Error> {
        let row = client.query_one(Self::QUERY, &self.as_slice()).await?;
        GetCityRow::from_row(&row)
    }
    pub async fn query_opt(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Option<GetCityRow>, tokio_postgres::Error> {
        let row = client.query_opt(Self::QUERY, &self.as_slice()).await?;
        match row {
            Some(row) => Ok(Some(GetCityRow::from_row(&row)?)),
            None => Ok(None),
        }
    }
    pub fn as_slice(&self) -> [&(dyn ToSql + Sync); 1] {
        [&self.slug]
    }
}
impl<'a> GetCity<'a> {
    pub const fn builder() -> GetCityBuilder<'a, ((),)> {
        GetCityBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct GetCityBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> GetCityBuilder<'a, ((),)> {
    pub fn slug(self, slug: &'a str) -> GetCityBuilder<'a, (&'a str,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        GetCityBuilder {
            fields: (slug,),
            _phantom,
        }
    }
}
impl<'a> GetCityBuilder<'a, (&'a str,)> {
    pub const fn build(self) -> GetCity<'a> {
        let (slug,) = self.fields;
        GetCity { slug }
    }
}
pub struct CreateCityRow {
    pub slug: String,
    pub name: String,
}
impl CreateCityRow {
    pub fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(Self {
            slug: row.try_get(0)?,
            name: row.try_get(1)?,
        })
    }
}
pub struct CreateCity<'a> {
    name: &'a str,
    slug: &'a str,
}
impl<'a> CreateCity<'a> {
    pub const QUERY: &'static str = r"INSERT INTO city (
    name,
    slug
) VALUES (
    $1,
    $2
) RETURNING slug, name";
    pub async fn query_one(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<CreateCityRow, tokio_postgres::Error> {
        let row = client.query_one(Self::QUERY, &self.as_slice()).await?;
        CreateCityRow::from_row(&row)
    }
    pub async fn query_opt(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Option<CreateCityRow>, tokio_postgres::Error> {
        let row = client.query_opt(Self::QUERY, &self.as_slice()).await?;
        match row {
            Some(row) => Ok(Some(CreateCityRow::from_row(&row)?)),
            None => Ok(None),
        }
    }
    pub fn as_slice(&self) -> [&(dyn ToSql + Sync); 2] {
        [&self.name, &self.slug]
    }
}
impl<'a> CreateCity<'a> {
    pub const fn builder() -> CreateCityBuilder<'a, ((), ())> {
        CreateCityBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CreateCityBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Slug> CreateCityBuilder<'a, ((), Slug)> {
    pub fn name(self, name: &'a str) -> CreateCityBuilder<'a, (&'a str, Slug)> {
        let ((), slug) = self.fields;
        let _phantom = self._phantom;
        CreateCityBuilder {
            fields: (name, slug),
            _phantom,
        }
    }
}
impl<'a, Name> CreateCityBuilder<'a, (Name, ())> {
    pub fn slug(self, slug: &'a str) -> CreateCityBuilder<'a, (Name, &'a str)> {
        let (name, ()) = self.fields;
        let _phantom = self._phantom;
        CreateCityBuilder {
            fields: (name, slug),
            _phantom,
        }
    }
}
impl<'a> CreateCityBuilder<'a, (&'a str, &'a str)> {
    pub const fn build(self) -> CreateCity<'a> {
        let (name, slug) = self.fields;
        CreateCity { name, slug }
    }
}
pub struct UpdateCityNameRow {}
impl UpdateCityNameRow {
    pub fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(Self {})
    }
}
pub struct UpdateCityName<'a> {
    slug: &'a str,
    name: &'a str,
}
impl<'a> UpdateCityName<'a> {
    pub const QUERY: &'static str = r"UPDATE city
SET name = $2
WHERE slug = $1";
    pub async fn execute(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<u64, tokio_postgres::Error> {
        client.execute(Self::QUERY, &self.as_slice()).await
    }
    pub fn as_slice(&self) -> [&(dyn ToSql + Sync); 2] {
        [&self.slug, &self.name]
    }
}
impl<'a> UpdateCityName<'a> {
    pub const fn builder() -> UpdateCityNameBuilder<'a, ((), ())> {
        UpdateCityNameBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct UpdateCityNameBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Name> UpdateCityNameBuilder<'a, ((), Name)> {
    pub fn slug(self, slug: &'a str) -> UpdateCityNameBuilder<'a, (&'a str, Name)> {
        let ((), name) = self.fields;
        let _phantom = self._phantom;
        UpdateCityNameBuilder {
            fields: (slug, name),
            _phantom,
        }
    }
}
impl<'a, Slug> UpdateCityNameBuilder<'a, (Slug, ())> {
    pub fn name(self, name: &'a str) -> UpdateCityNameBuilder<'a, (Slug, &'a str)> {
        let (slug, ()) = self.fields;
        let _phantom = self._phantom;
        UpdateCityNameBuilder {
            fields: (slug, name),
            _phantom,
        }
    }
}
impl<'a> UpdateCityNameBuilder<'a, (&'a str, &'a str)> {
    pub const fn build(self) -> UpdateCityName<'a> {
        let (slug, name) = self.fields;
        UpdateCityName { slug, name }
    }
}
pub struct ListVenuesRow {
    pub id: i32,
    pub status: Status,
    pub statuses: Option<Vec<Status>>,
    pub slug: String,
    pub name: String,
    pub city: String,
    pub spotify_playlist: String,
    pub songkick_id: Option<String>,
    pub tags: Option<Vec<String>>,
    pub created_at: std::time::SystemTime,
}
impl ListVenuesRow {
    pub fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(Self {
            id: row.try_get(0)?,
            status: row.try_get(1)?,
            statuses: row.try_get(2)?,
            slug: row.try_get(3)?,
            name: row.try_get(4)?,
            city: row.try_get(5)?,
            spotify_playlist: row.try_get(6)?,
            songkick_id: row.try_get(7)?,
            tags: row.try_get(8)?,
            created_at: row.try_get(9)?,
        })
    }
}
pub struct ListVenues<'a> {
    city: &'a str,
}
impl<'a> ListVenues<'a> {
    pub const QUERY: &'static str = r"SELECT id, status, statuses, slug, name, city, spotify_playlist, songkick_id, tags, created_at
FROM venue
WHERE city = $1
ORDER BY name";
    pub async fn query_many(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Vec<ListVenuesRow>, tokio_postgres::Error> {
        let rows = client.query(Self::QUERY, &[&self.city]).await?;
        rows.into_iter()
            .map(|r| ListVenuesRow::from_row(&r))
            .collect()
    }
    pub async fn query_stream(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<tokio_postgres::RowStream, tokio_postgres::Error> {
        let st = client
            .query_raw(Self::QUERY, self.as_slice().into_iter())
            .await?;
        Ok(st)
    }
    pub fn as_slice(&self) -> [&(dyn ToSql + Sync); 1] {
        [&self.city]
    }
}
impl<'a> ListVenues<'a> {
    pub const fn builder() -> ListVenuesBuilder<'a, ((),)> {
        ListVenuesBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct ListVenuesBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> ListVenuesBuilder<'a, ((),)> {
    pub fn city(self, city: &'a str) -> ListVenuesBuilder<'a, (&'a str,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        ListVenuesBuilder {
            fields: (city,),
            _phantom,
        }
    }
}
impl<'a> ListVenuesBuilder<'a, (&'a str,)> {
    pub const fn build(self) -> ListVenues<'a> {
        let (city,) = self.fields;
        ListVenues { city }
    }
}
pub struct DeleteVenueRow {}
impl DeleteVenueRow {
    pub fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(Self {})
    }
}
pub struct DeleteVenue<'a> {
    slug: &'a str,
}
impl<'a> DeleteVenue<'a> {
    pub const QUERY: &'static str = r"DELETE FROM venue
WHERE slug = $1 AND slug = $1";
    pub async fn execute(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<u64, tokio_postgres::Error> {
        client.execute(Self::QUERY, &self.as_slice()).await
    }
    pub fn as_slice(&self) -> [&(dyn ToSql + Sync); 1] {
        [&self.slug]
    }
}
impl<'a> DeleteVenue<'a> {
    pub const fn builder() -> DeleteVenueBuilder<'a, ((),)> {
        DeleteVenueBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct DeleteVenueBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> DeleteVenueBuilder<'a, ((),)> {
    pub fn slug(self, slug: &'a str) -> DeleteVenueBuilder<'a, (&'a str,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        DeleteVenueBuilder {
            fields: (slug,),
            _phantom,
        }
    }
}
impl<'a> DeleteVenueBuilder<'a, (&'a str,)> {
    pub const fn build(self) -> DeleteVenue<'a> {
        let (slug,) = self.fields;
        DeleteVenue { slug }
    }
}
pub struct GetVenueRow {
    pub id: i32,
    pub status: Status,
    pub statuses: Option<Vec<Status>>,
    pub slug: String,
    pub name: String,
    pub city: String,
    pub spotify_playlist: String,
    pub songkick_id: Option<String>,
    pub tags: Option<Vec<String>>,
    pub created_at: std::time::SystemTime,
}
impl GetVenueRow {
    pub fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(Self {
            id: row.try_get(0)?,
            status: row.try_get(1)?,
            statuses: row.try_get(2)?,
            slug: row.try_get(3)?,
            name: row.try_get(4)?,
            city: row.try_get(5)?,
            spotify_playlist: row.try_get(6)?,
            songkick_id: row.try_get(7)?,
            tags: row.try_get(8)?,
            created_at: row.try_get(9)?,
        })
    }
}
pub struct GetVenue<'a> {
    slug: &'a str,
    city: &'a str,
}
impl<'a> GetVenue<'a> {
    pub const QUERY: &'static str = r"SELECT id, status, statuses, slug, name, city, spotify_playlist, songkick_id, tags, created_at
FROM venue
WHERE slug = $1 AND city = $2";
    pub async fn query_one(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<GetVenueRow, tokio_postgres::Error> {
        let row = client.query_one(Self::QUERY, &self.as_slice()).await?;
        GetVenueRow::from_row(&row)
    }
    pub async fn query_opt(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Option<GetVenueRow>, tokio_postgres::Error> {
        let row = client.query_opt(Self::QUERY, &self.as_slice()).await?;
        match row {
            Some(row) => Ok(Some(GetVenueRow::from_row(&row)?)),
            None => Ok(None),
        }
    }
    pub fn as_slice(&self) -> [&(dyn ToSql + Sync); 2] {
        [&self.slug, &self.city]
    }
}
impl<'a> GetVenue<'a> {
    pub const fn builder() -> GetVenueBuilder<'a, ((), ())> {
        GetVenueBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct GetVenueBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, City> GetVenueBuilder<'a, ((), City)> {
    pub fn slug(self, slug: &'a str) -> GetVenueBuilder<'a, (&'a str, City)> {
        let ((), city) = self.fields;
        let _phantom = self._phantom;
        GetVenueBuilder {
            fields: (slug, city),
            _phantom,
        }
    }
}
impl<'a, Slug> GetVenueBuilder<'a, (Slug, ())> {
    pub fn city(self, city: &'a str) -> GetVenueBuilder<'a, (Slug, &'a str)> {
        let (slug, ()) = self.fields;
        let _phantom = self._phantom;
        GetVenueBuilder {
            fields: (slug, city),
            _phantom,
        }
    }
}
impl<'a> GetVenueBuilder<'a, (&'a str, &'a str)> {
    pub const fn build(self) -> GetVenue<'a> {
        let (slug, city) = self.fields;
        GetVenue { slug, city }
    }
}
pub struct CreateVenueRow {
    pub id: i32,
}
impl CreateVenueRow {
    pub fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(Self {
            id: row.try_get(0)?,
        })
    }
}
pub struct CreateVenue<'a> {
    slug: &'a str,
    name: &'a str,
    city: &'a str,
    spotify_playlist: &'a str,
    status: Status,
    statuses: Option<&'a [Status]>,
    tags: Option<&'a [String]>,
}
impl<'a> CreateVenue<'a> {
    pub const QUERY: &'static str = r"INSERT INTO venue (
    slug,
    name,
    city,
    created_at,
    spotify_playlist,
    status,
    statuses,
    tags
) VALUES (
    $1,
    $2,
    $3,
    NOW(),
    $4,
    $5,
    $6,
    $7
) RETURNING id";
    pub async fn query_one(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<CreateVenueRow, tokio_postgres::Error> {
        let row = client.query_one(Self::QUERY, &self.as_slice()).await?;
        CreateVenueRow::from_row(&row)
    }
    pub async fn query_opt(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Option<CreateVenueRow>, tokio_postgres::Error> {
        let row = client.query_opt(Self::QUERY, &self.as_slice()).await?;
        match row {
            Some(row) => Ok(Some(CreateVenueRow::from_row(&row)?)),
            None => Ok(None),
        }
    }
    pub fn as_slice(&self) -> [&(dyn ToSql + Sync); 7] {
        [
            &self.slug,
            &self.name,
            &self.city,
            &self.spotify_playlist,
            &self.status,
            &self.statuses,
            &self.tags,
        ]
    }
}
impl<'a> CreateVenue<'a> {
    pub const fn builder() -> CreateVenueBuilder<'a, ((), (), (), (), (), (), ())> {
        CreateVenueBuilder {
            fields: ((), (), (), (), (), (), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CreateVenueBuilder<'a, Fields = ((), (), (), (), (), (), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Name, City, SpotifyPlaylist, Status, Statuses, Tags>
    CreateVenueBuilder<'a, ((), Name, City, SpotifyPlaylist, Status, Statuses, Tags)>
{
    pub fn slug(
        self,
        slug: &'a str,
    ) -> CreateVenueBuilder<'a, (&'a str, Name, City, SpotifyPlaylist, Status, Statuses, Tags)>
    {
        let ((), name, city, spotify_playlist, status, statuses, tags) = self.fields;
        let _phantom = self._phantom;
        CreateVenueBuilder {
            fields: (slug, name, city, spotify_playlist, status, statuses, tags),
            _phantom,
        }
    }
}
impl<'a, Slug, City, SpotifyPlaylist, Status, Statuses, Tags>
    CreateVenueBuilder<'a, (Slug, (), City, SpotifyPlaylist, Status, Statuses, Tags)>
{
    pub fn name(
        self,
        name: &'a str,
    ) -> CreateVenueBuilder<'a, (Slug, &'a str, City, SpotifyPlaylist, Status, Statuses, Tags)>
    {
        let (slug, (), city, spotify_playlist, status, statuses, tags) = self.fields;
        let _phantom = self._phantom;
        CreateVenueBuilder {
            fields: (slug, name, city, spotify_playlist, status, statuses, tags),
            _phantom,
        }
    }
}
impl<'a, Slug, Name, SpotifyPlaylist, Status, Statuses, Tags>
    CreateVenueBuilder<'a, (Slug, Name, (), SpotifyPlaylist, Status, Statuses, Tags)>
{
    pub fn city(
        self,
        city: &'a str,
    ) -> CreateVenueBuilder<'a, (Slug, Name, &'a str, SpotifyPlaylist, Status, Statuses, Tags)>
    {
        let (slug, name, (), spotify_playlist, status, statuses, tags) = self.fields;
        let _phantom = self._phantom;
        CreateVenueBuilder {
            fields: (slug, name, city, spotify_playlist, status, statuses, tags),
            _phantom,
        }
    }
}
impl<'a, Slug, Name, City, Status, Statuses, Tags>
    CreateVenueBuilder<'a, (Slug, Name, City, (), Status, Statuses, Tags)>
{
    pub fn spotify_playlist(
        self,
        spotify_playlist: &'a str,
    ) -> CreateVenueBuilder<'a, (Slug, Name, City, &'a str, Status, Statuses, Tags)> {
        let (slug, name, city, (), status, statuses, tags) = self.fields;
        let _phantom = self._phantom;
        CreateVenueBuilder {
            fields: (slug, name, city, spotify_playlist, status, statuses, tags),
            _phantom,
        }
    }
}
impl<'a, Slug, Name, City, SpotifyPlaylist, Statuses, Tags>
    CreateVenueBuilder<'a, (Slug, Name, City, SpotifyPlaylist, (), Statuses, Tags)>
{
    pub fn status(
        self,
        status: Status,
    ) -> CreateVenueBuilder<'a, (Slug, Name, City, SpotifyPlaylist, Status, Statuses, Tags)> {
        let (slug, name, city, spotify_playlist, (), statuses, tags) = self.fields;
        let _phantom = self._phantom;
        CreateVenueBuilder {
            fields: (slug, name, city, spotify_playlist, status, statuses, tags),
            _phantom,
        }
    }
}
impl<'a, Slug, Name, City, SpotifyPlaylist, Status, Tags>
    CreateVenueBuilder<'a, (Slug, Name, City, SpotifyPlaylist, Status, (), Tags)>
{
    pub fn statuses(
        self,
        statuses: Option<&'a [Status]>,
    ) -> CreateVenueBuilder<
        'a,
        (
            Slug,
            Name,
            City,
            SpotifyPlaylist,
            Status,
            Option<&'a [Status]>,
            Tags,
        ),
    > {
        let (slug, name, city, spotify_playlist, status, (), tags) = self.fields;
        let _phantom = self._phantom;
        CreateVenueBuilder {
            fields: (slug, name, city, spotify_playlist, status, statuses, tags),
            _phantom,
        }
    }
}
impl<'a, Slug, Name, City, SpotifyPlaylist, Status, Statuses>
    CreateVenueBuilder<'a, (Slug, Name, City, SpotifyPlaylist, Status, Statuses, ())>
{
    pub fn tags(
        self,
        tags: Option<&'a [String]>,
    ) -> CreateVenueBuilder<
        'a,
        (
            Slug,
            Name,
            City,
            SpotifyPlaylist,
            Status,
            Statuses,
            Option<&'a [String]>,
        ),
    > {
        let (slug, name, city, spotify_playlist, status, statuses, ()) = self.fields;
        let _phantom = self._phantom;
        CreateVenueBuilder {
            fields: (slug, name, city, spotify_playlist, status, statuses, tags),
            _phantom,
        }
    }
}
impl<'a>
    CreateVenueBuilder<
        'a,
        (
            &'a str,
            &'a str,
            &'a str,
            &'a str,
            Status,
            Option<&'a [Status]>,
            Option<&'a [String]>,
        ),
    >
{
    pub const fn build(self) -> CreateVenue<'a> {
        let (slug, name, city, spotify_playlist, status, statuses, tags) = self.fields;
        CreateVenue {
            slug,
            name,
            city,
            spotify_playlist,
            status,
            statuses,
            tags,
        }
    }
}
pub struct UpdateVenueNameRow {
    pub id: i32,
}
impl UpdateVenueNameRow {
    pub fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(Self {
            id: row.try_get(0)?,
        })
    }
}
pub struct UpdateVenueName<'a> {
    slug: &'a str,
    name: &'a str,
}
impl<'a> UpdateVenueName<'a> {
    pub const QUERY: &'static str = r"UPDATE venue
SET name = $2
WHERE slug = $1
RETURNING id";
    pub async fn query_one(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<UpdateVenueNameRow, tokio_postgres::Error> {
        let row = client.query_one(Self::QUERY, &self.as_slice()).await?;
        UpdateVenueNameRow::from_row(&row)
    }
    pub async fn query_opt(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Option<UpdateVenueNameRow>, tokio_postgres::Error> {
        let row = client.query_opt(Self::QUERY, &self.as_slice()).await?;
        match row {
            Some(row) => Ok(Some(UpdateVenueNameRow::from_row(&row)?)),
            None => Ok(None),
        }
    }
    pub fn as_slice(&self) -> [&(dyn ToSql + Sync); 2] {
        [&self.slug, &self.name]
    }
}
impl<'a> UpdateVenueName<'a> {
    pub const fn builder() -> UpdateVenueNameBuilder<'a, ((), ())> {
        UpdateVenueNameBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct UpdateVenueNameBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Name> UpdateVenueNameBuilder<'a, ((), Name)> {
    pub fn slug(self, slug: &'a str) -> UpdateVenueNameBuilder<'a, (&'a str, Name)> {
        let ((), name) = self.fields;
        let _phantom = self._phantom;
        UpdateVenueNameBuilder {
            fields: (slug, name),
            _phantom,
        }
    }
}
impl<'a, Slug> UpdateVenueNameBuilder<'a, (Slug, ())> {
    pub fn name(self, name: &'a str) -> UpdateVenueNameBuilder<'a, (Slug, &'a str)> {
        let (slug, ()) = self.fields;
        let _phantom = self._phantom;
        UpdateVenueNameBuilder {
            fields: (slug, name),
            _phantom,
        }
    }
}
impl<'a> UpdateVenueNameBuilder<'a, (&'a str, &'a str)> {
    pub const fn build(self) -> UpdateVenueName<'a> {
        let (slug, name) = self.fields;
        UpdateVenueName { slug, name }
    }
}
pub struct VenueCountByCityRow {
    pub city: String,
    pub count: i64,
}
impl VenueCountByCityRow {
    pub fn from_row(row: &tokio_postgres::Row) -> Result<Self, tokio_postgres::Error> {
        Ok(Self {
            city: row.try_get(0)?,
            count: row.try_get(1)?,
        })
    }
}
pub struct VenueCountByCity;
impl VenueCountByCity {
    pub const QUERY: &'static str = r"SELECT
    city,
    count(*)
FROM venue
GROUP BY 1
ORDER BY 1";
    pub async fn query_many(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<Vec<VenueCountByCityRow>, tokio_postgres::Error> {
        let rows = client.query(Self::QUERY, &[]).await?;
        rows.into_iter()
            .map(|r| VenueCountByCityRow::from_row(&r))
            .collect()
    }
    pub async fn query_stream(
        &self,
        client: &impl tokio_postgres::GenericClient,
    ) -> Result<tokio_postgres::RowStream, tokio_postgres::Error> {
        let st = client
            .query_raw(Self::QUERY, self.as_slice().into_iter())
            .await?;
        Ok(st)
    }
    pub fn as_slice(&self) -> [&(dyn ToSql + Sync); 0] {
        []
    }
}
impl VenueCountByCity {
    pub const fn builder() -> VenueCountByCityBuilder<'static, ()> {
        VenueCountByCityBuilder {
            fields: (),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct VenueCountByCityBuilder<'a, Fields = ()> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> VenueCountByCityBuilder<'a, ()> {
    pub const fn build(self) -> VenueCountByCity {
        let () = self.fields;
        VenueCountByCity {}
    }
}
