//! Code generated by sqlc-gen-rust. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-gen-rust version: v0.1.8

#[derive(sqlx::FromRow)]
pub struct GetMappingRow {
    pub bool_val: bool,
    pub tinyint_val: i8,
    pub smallint_val: i16,
    pub int_val: i32,
    pub int_nullable_val: Option<i32>,
    pub bigint_val: i64,
    pub float_val: f32,
    pub double_val: f64,
    pub text_val: String,
    pub blob_val: Vec<u8>,
    pub datetime_val: chrono::NaiveDateTime,
    pub date_val: chrono::NaiveDate,
    pub time_val: chrono::NaiveTime,
    pub json_val: serde_json::Value,
}

pub struct GetMapping;
impl GetMapping {
    pub const QUERY: &'static str = r"SELECT
    bool_val,
    tinyint_val,
    smallint_val,
    int_val,
    int_nullable_val,
    bigint_val,
    float_val,
    double_val,
    text_val,
    blob_val,
    datetime_val,
    date_val,
    time_val,
    json_val
FROM mapping";

    pub fn query<'a>() -> sqlx::query::QueryAs<'a, sqlx::MySql, GetMappingRow, <sqlx::MySql as sqlx::Database>::Arguments<'a>> {
        sqlx::query_as::<_, GetMappingRow>(Self::QUERY)
    }

    pub async fn query_one<'e, A>(conn: A) -> Result<GetMappingRow, sqlx::Error>
    where
        A: sqlx::Acquire<'e, Database = sqlx::MySql>,
    {
        let mut conn = conn.acquire().await?;
        let row = Self::query().fetch_one(&mut *conn).await?;
        Ok(row)
    }
}

pub struct InsertMapping<'a> {
    bool_val: bool,
    tinyint_val: i8,
    smallint_val: i16,
    int_val: i32,
    int_nullable_val: Option<i32>,
    bigint_val: i64,
    float_val: f32,
    double_val: f64,
    text_val: &'a str,
    blob_val: &'a [u8],
    datetime_val: &'a chrono::NaiveDateTime,
    date_val: &'a chrono::NaiveDate,
    time_val: &'a chrono::NaiveTime,
    json_val: &'a serde_json::Value,
}

pub struct InsertMappingBuilder<'a> {
    bool_val: Option<bool>,
    tinyint_val: Option<i8>,
    smallint_val: Option<i16>,
    int_val: Option<i32>,
    int_nullable_val: Option<Option<i32>>,
    bigint_val: Option<i64>,
    float_val: Option<f32>,
    double_val: Option<f64>,
    text_val: Option<&'a str>,
    blob_val: Option<&'a [u8]>,
    datetime_val: Option<&'a chrono::NaiveDateTime>,
    date_val: Option<&'a chrono::NaiveDate>,
    time_val: Option<&'a chrono::NaiveTime>,
    json_val: Option<&'a serde_json::Value>,
}

impl<'a> InsertMapping<'a> {
    pub const QUERY: &'static str = r"INSERT INTO mapping (
    bool_val,
    tinyint_val,
    smallint_val,
    int_val,
    int_nullable_val,
    bigint_val,
    float_val,
    double_val,
    text_val,
    blob_val,
    datetime_val,
    date_val,
    time_val,
    json_val
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)";

    pub fn builder() -> InsertMappingBuilder<'a> {
        InsertMappingBuilder {
            bool_val: None,
            tinyint_val: None,
            smallint_val: None,
            int_val: None,
            int_nullable_val: None,
            bigint_val: None,
            float_val: None,
            double_val: None,
            text_val: None,
            blob_val: None,
            datetime_val: None,
            date_val: None,
            time_val: None,
            json_val: None,
        }
    }

    fn query(&'a self) -> sqlx::query::Query<'a, sqlx::MySql, <sqlx::MySql as sqlx::Database>::Arguments<'a>> {
        sqlx::query(Self::QUERY)
            .bind(self.bool_val)
            .bind(self.tinyint_val)
            .bind(self.smallint_val)
            .bind(self.int_val)
            .bind(self.int_nullable_val)
            .bind(self.bigint_val)
            .bind(self.float_val)
            .bind(self.double_val)
            .bind(self.text_val)
            .bind(self.blob_val)
            .bind(self.datetime_val)
            .bind(self.date_val)
            .bind(self.time_val)
            .bind(self.json_val)
    }

    pub async fn execute<'e, A>(&'a self, conn: A) -> Result<sqlx::mysql::MySqlQueryResult, sqlx::Error>
    where
        A: sqlx::Acquire<'e, Database = sqlx::MySql>,
    {
        let mut conn = conn.acquire().await?;
        let res = self.query().execute(&mut *conn).await?;
        Ok(res)
    }
}

impl<'a> InsertMappingBuilder<'a> {
    pub fn bool_val(mut self, v: bool) -> Self { self.bool_val = Some(v); self }
    pub fn tinyint_val(mut self, v: i8) -> Self { self.tinyint_val = Some(v); self }
    pub fn smallint_val(mut self, v: i16) -> Self { self.smallint_val = Some(v); self }
    pub fn int_val(mut self, v: i32) -> Self { self.int_val = Some(v); self }
    pub fn int_nullable_val(mut self, v: Option<i32>) -> Self { self.int_nullable_val = Some(v); self }
    pub fn bigint_val(mut self, v: i64) -> Self { self.bigint_val = Some(v); self }
    pub fn float_val(mut self, v: f32) -> Self { self.float_val = Some(v); self }
    pub fn double_val(mut self, v: f64) -> Self { self.double_val = Some(v); self }
    pub fn text_val(mut self, v: &'a str) -> Self { self.text_val = Some(v); self }
    pub fn blob_val(mut self, v: &'a [u8]) -> Self { self.blob_val = Some(v); self }
    pub fn datetime_val(mut self, v: &'a chrono::NaiveDateTime) -> Self { self.datetime_val = Some(v); self }
    pub fn date_val(mut self, v: &'a chrono::NaiveDate) -> Self { self.date_val = Some(v); self }
    pub fn time_val(mut self, v: &'a chrono::NaiveTime) -> Self { self.time_val = Some(v); self }
    pub fn json_val(mut self, v: &'a serde_json::Value) -> Self { self.json_val = Some(v); self }

    pub fn build(self) -> InsertMapping<'a> {
        InsertMapping {
            bool_val: self.bool_val.expect("bool_val not set"),
            tinyint_val: self.tinyint_val.expect("tinyint_val not set"),
            smallint_val: self.smallint_val.expect("smallint_val not set"),
            int_val: self.int_val.expect("int_val not set"),
            int_nullable_val: self.int_nullable_val.expect("int_nullable_val not set"),
            bigint_val: self.bigint_val.expect("bigint_val not set"),
            float_val: self.float_val.expect("float_val not set"),
            double_val: self.double_val.expect("double_val not set"),
            text_val: self.text_val.expect("text_val not set"),
            blob_val: self.blob_val.expect("blob_val not set"),
            datetime_val: self.datetime_val.expect("datetime_val not set"),
            date_val: self.date_val.expect("date_val not set"),
            time_val: self.time_val.expect("time_val not set"),
            json_val: self.json_val.expect("json_val not set"),
        }
    }
}
