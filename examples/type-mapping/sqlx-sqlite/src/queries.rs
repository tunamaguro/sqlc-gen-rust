//! Code generated by sqlc-gen-rust. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-gen-rust version: v0.1.8

#[derive(sqlx::FromRow)]
pub struct GetMappingRow {
    pub bool_val: bool,
    pub int_val: i64,
    pub int_nullable_val: Option<i64>,
    pub real_val: f64,
    pub text_val: String,
    pub blob_val: Vec<u8>,
    pub datetime_val: chrono::NaiveDateTime,
    pub date_val: chrono::NaiveDate,
    pub time_val: chrono::NaiveTime,
    pub json_val: serde_json::Value,
}

pub struct GetMapping;
impl GetMapping {
    pub const QUERY: &'static str = r"SELECT
    bool_val,
    int_val,
    int_nullable_val,
    real_val,
    text_val,
    blob_val,
    datetime_val,
    date_val,
    time_val,
    json_val
FROM mapping";

    pub fn query<'a>() -> sqlx::query::QueryAs<'a, sqlx::Sqlite, GetMappingRow, <sqlx::Sqlite as sqlx::Database>::Arguments<'a>> {
        sqlx::query_as::<_, GetMappingRow>(Self::QUERY)
    }

    pub async fn query_one<'e, A>(conn: A) -> Result<GetMappingRow, sqlx::Error>
    where
        A: sqlx::Acquire<'e, Database = sqlx::Sqlite>,
    {
        let mut conn = conn.acquire().await?;
        let row = Self::query().fetch_one(&mut *conn).await?;
        Ok(row)
    }
}

pub struct InsertMapping<'a> {
    bool_val: bool,
    int_val: i64,
    int_nullable_val: Option<i64>,
    real_val: f64,
    text_val: &'a str,
    blob_val: &'a [u8],
    datetime_val: &'a chrono::NaiveDateTime,
    date_val: &'a chrono::NaiveDate,
    time_val: &'a chrono::NaiveTime,
    json_val: &'a serde_json::Value,
}

pub struct InsertMappingBuilder<'a> {
    bool_val: Option<bool>,
    int_val: Option<i64>,
    int_nullable_val: Option<Option<i64>>,
    real_val: Option<f64>,
    text_val: Option<&'a str>,
    blob_val: Option<&'a [u8]>,
    datetime_val: Option<&'a chrono::NaiveDateTime>,
    date_val: Option<&'a chrono::NaiveDate>,
    time_val: Option<&'a chrono::NaiveTime>,
    json_val: Option<&'a serde_json::Value>,
}

impl<'a> InsertMapping<'a> {
    pub const QUERY: &'static str = r"INSERT INTO mapping (
    bool_val,
    int_val,
    int_nullable_val,
    real_val,
    text_val,
    blob_val,
    datetime_val,
    date_val,
    time_val,
    json_val
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)";

    pub fn builder() -> InsertMappingBuilder<'a> {
        InsertMappingBuilder {
            bool_val: None,
            int_val: None,
            int_nullable_val: None,
            real_val: None,
            text_val: None,
            blob_val: None,
            datetime_val: None,
            date_val: None,
            time_val: None,
            json_val: None,
        }
    }

    fn query(&'a self) -> sqlx::query::Query<'a, sqlx::Sqlite, <sqlx::Sqlite as sqlx::Database>::Arguments<'a>> {
        sqlx::query(Self::QUERY)
            .bind(self.bool_val)
            .bind(self.int_val)
            .bind(self.int_nullable_val)
            .bind(self.real_val)
            .bind(self.text_val)
            .bind(self.blob_val)
            .bind(self.datetime_val)
            .bind(self.date_val)
            .bind(self.time_val)
            .bind(self.json_val)
    }

    pub async fn execute<'e, A>(&'a self, conn: A) -> Result<sqlx::sqlite::SqliteQueryResult, sqlx::Error>
    where
        A: sqlx::Acquire<'e, Database = sqlx::Sqlite>,
    {
        let mut conn = conn.acquire().await?;
        let res = self.query().execute(&mut *conn).await?;
        Ok(res)
    }
}

impl<'a> InsertMappingBuilder<'a> {
    pub fn bool_val(mut self, v: bool) -> Self { self.bool_val = Some(v); self }
    pub fn int_val(mut self, v: i64) -> Self { self.int_val = Some(v); self }
    pub fn int_nullable_val(mut self, v: Option<i64>) -> Self { self.int_nullable_val = Some(v); self }
    pub fn real_val(mut self, v: f64) -> Self { self.real_val = Some(v); self }
    pub fn text_val(mut self, v: &'a str) -> Self { self.text_val = Some(v); self }
    pub fn blob_val(mut self, v: &'a [u8]) -> Self { self.blob_val = Some(v); self }
    pub fn datetime_val(mut self, v: &'a chrono::NaiveDateTime) -> Self { self.datetime_val = Some(v); self }
    pub fn date_val(mut self, v: &'a chrono::NaiveDate) -> Self { self.date_val = Some(v); self }
    pub fn time_val(mut self, v: &'a chrono::NaiveTime) -> Self { self.time_val = Some(v); self }
    pub fn json_val(mut self, v: &'a serde_json::Value) -> Self { self.json_val = Some(v); self }

    pub fn build(self) -> InsertMapping<'a> {
        InsertMapping {
            bool_val: self.bool_val.expect("bool_val not set"),
            int_val: self.int_val.expect("int_val not set"),
            int_nullable_val: self.int_nullable_val.expect("int_nullable_val not set"),
            real_val: self.real_val.expect("real_val not set"),
            text_val: self.text_val.expect("text_val not set"),
            blob_val: self.blob_val.expect("blob_val not set"),
            datetime_val: self.datetime_val.expect("datetime_val not set"),
            date_val: self.date_val.expect("date_val not set"),
            time_val: self.time_val.expect("time_val not set"),
            json_val: self.json_val.expect("json_val not set"),
        }
    }
}
